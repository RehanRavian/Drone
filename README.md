# Paperino - An open source drone

In this repository you will find the final version of a complete solution to stabilize and drive a quadcopter. The firmware is coded in C within Ateml Studio IDE.
Inside the "Solution" folder you'll find the project ready to be opened by Atmel Studio, while in the "Code" folder contains only the source files.

## Considerations on data filtering and sensor fusion

Below can be found some graph displaying raw measurements, pitch and roll converted values and filtered ones. The graph relates to laboratory taken measures, and are thought to simulate worst case scenarios from real flight condition.

## Getting started
 
In this section you'll find how to get started with Paperino's firmware.

### Opening solution in Atmel Studio

To open the project, start Atmel Studio, click on "Open Project" and select the file with .prj extension.

### Build and load

To upload and build the files you have to plug in your AVR-ISP programmer, and select it from the "Tools" men√π. please verify the chip signature, in my case "", the one for Atmega32u4.

### Test, fly, enjoy!

It's now time to test your setup and enjoy flying around. USART debug is set by default, so you can attach a TTL serial adapter to RX-TX pins and read data. 57.6kBaud, 1 bit stop, 0 parity bits.

## In depth anaysis of the firmware

I tried to comment the code as much as possibile, but for additional clarity I'll write something on its core functions.

### TWI interface

I've selected the MPU6050 accelerometer+gyroscope becasue it is cheap, quite precise and can be found pretty easly. The communication relies on a i2c bus, handled by hardware from the Atmega. All the registers are set in the library `i2c.c` and can be accessed by the functions: 
```
void TWI_transmit_8bit();
```
The transmit functions 

### IMU

At startup the IMU is initialize writing to proper registers, and returns the `WHO_I_AM` value. This should be `0x68`, the address of the i2C slave. Raw data can be accessed by functions:
```
void FUNCRION
```
Those reads are about two 8-bit, and have to be converted to g or m/s^2 values according to full scale ranges, reported on the datasheet.
The registers are "burst-read", so that the data computed refers to a measurement only, and not mix data from two successive sensor readings. Raw and elaborated values can be accessed by every .c file, and are updated every `read_all()` call.

### Debug
I'm currently working on a graphic IDE for controlling and debugging the code. The communication protocol with the computer consists in sending a value from PC and receiving back the data requested. In the MATLAB folder I have uploaded some scripts that reads several data from the serial port, that have to be defined at the beginning of the code. More on this soon!

### PWM generation
PWM for motors is generated by an hardware feature of the TIM1 and TIM3. Those are 16-bit timers, and are also used to update the `System_Tick`. Additional PWM output uses TIM4 and are thought for an additional gimbal for cinematic drones. I have also included 3 software PWM outputs to drive RGB leds, but those ports can be accessed and redirected to do other functions.

### Sensor fusion
At the moment, I'm working on a simplified Kalman Filter for processing flight data, but the computational power on those 8-bit AVR microcontrollers in not a lot, and the algorith optimization process is taking longer than expected. I'll upload my code as soon I'll have a working beta. The actual code uses a complementary filter, which is lightweight and proved to be more that enough for the majority of applications. You can trim how much data will be taken by the accelerometer and how much from the gyroscope in the `filter.c` file.
